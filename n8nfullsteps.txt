Here’s a hands-on plan to build your AI-powered claims agent in n8n—from scoping to a working workflow with human-in-the-loop review, escalations, customer comms, and robust error handling. I’ll give you concrete nodes, configurations, and copy-paste code you can drop into Function nodes and prompts.

Overview of what we’ll build
- A main "Intake + AI Triage" workflow to fetch new claims, analyze them with an LLM, decide auto vs. human review, notify Slack, and update systems.
- A "Review Decision Receiver" workflow (Webhook) to capture claims experts’ decisions from your internal dashboard or Slack and drive customer communications and system updates.
- An "Error Handler" workflow to catch any failure and alert + log.
- Data stored in Postgres (recommended) for dashboarding, with simple alternatives (Google Sheets) if needed.
- Clean retry logic, fallbacks for LLM failures, and idempotency.

Step 1) Scope the agent: goals and I/O
Goals
- Identify and rank AI-flagged claims for human review based on severity, fraud risk, and policy rules.
- Provide suggested actions and draft customer messages.
- Manage escalations to senior reviewers.
- Synchronize status with your claims system and keep a full audit trail.

Inputs
- Claim event/payload from your claims system (via webhook or polling):
  - claim_id, customer_id, customer_name, contact_email, contact_phone
  - claim_type, amount, currency, incident_date, submission_date
  - description, attachments metadata, location, policy_id
  - prior_claims_count, policy_tenure_months, risk_score (if available)
- Optional: policy rules and thresholds configured in DB or in n8n static data.

Outputs
- DB record capturing AI analysis and routing decision.
- Slack message to review queue (with link to dashboard).
- Customer communication (email/SMS) when auto-approved or after human decision.
- Status update in claims system via HTTP API.
- Logs/events for audit.

Key decisions/states
- triage_decision: AUTO_APPROVE | NEEDS_REVIEW | ESCALATE
- severity: 1–5
- fraud_risk: 0.0–1.0
- customer_next_step: SEND_PAYOUT | REQUEST_INFO | DENY | MANUAL_CALL
- lifecycle: NEW -> QUEUED_FOR_REVIEW -> DECIDED -> CUSTOMER_NOTIFIED -> CLOSED

Step 2) High-level architecture (flow)
- Intake (Webhook or Cron)
  - Fetch new claims -> normalize -> redact PII for LLM
  - LLM classification + reasoning -> structured JSON
  - Parse/validate -> decide branch
- Branches
  - Auto: update claims system, notify customer, log
  - Needs review: write to DB queue, notify Slack, await human decision (handled by the separate webhook)
- Decision Receiver (Webhook from dashboard/Slack)
  - Validate reviewer payload
  - Update DB + claims system
  - Notify customer
  - Log event + notify Slack
- Error handling
  - Central Error Trigger workflow -> Slack alert + log + optional retry

Step 3) Recommended n8n nodes
Core
- Trigger: Webhook or Cron
- HTTP Request (claims system API)
- Function (JS) for normalization, redaction, parsing, fallback logic
- OpenAI (Chat) for triage
- If / Switch / Set / Merge / Split In Batches
- Wait (for backoff/retry or scheduled steps)
- Postgres (or Google Sheets)
- Slack
- Gmail or SMTP, Twilio (SMS)
- Error Trigger

Optional
- Data Store or workflow static data for last processed watermark
- Notion/Airtable if you prefer those over Postgres
- Binary nodes for attachments if needed

Step 4) Node-by-node design and configuration

Workflow A: Claims Intake + AI Triage

A1) Trigger (pick one)
- Webhook (recommended if your claims system can push)
  - Path: /claims/new
  - HTTP Method: POST
  - Respond with: 200 and “accepted”
- Cron (if you need polling)
  - Every: 5 minutes
  - Next: HTTP Request to claims API to pull claims since last watermark

A2) Function: Watermark (only for polling)
Purpose: Track last processed timestamp across runs.
Code (Function node):
/**
 * Persist/advance a lastProcessedAt watermark across executions.
 * Use 'global' static data as a lightweight KV store.
 */
const globalData = this.getWorkflowStaticData('global');
const now = new Date().toISOString();
if (!globalData.lastProcessedAt) {
  globalData.lastProcessedAt = '1970-01-01T00:00:00.000Z';
}
return [
  {
    json: {
      lastProcessedAt: globalData.lastProcessedAt,
      now,
    },
  },
];

A3) HTTP Request: Fetch new claims (polling path)
- Method: GET
- URL: https://your-claims-api.example.com/claims?since={{$json.lastProcessedAt}}
- Authentication: As required (API key/OAuth)
- Response: JSON
- Split into Items: Yes (one item per claim)
- Continue On Fail: Off

A4) Function: Normalize and redact
Purpose: Map incoming claims into a clean schema and mask PII before LLM.
Code:
/**
 * Normalize claim fields and redact sensitive PII before sending to LLM.
 */
function redactEmail(email) {
  if (!email) return null;
  const [user, domain] = email.split('@');
  return `${user?.[0] || ''}***@${domain || '***'}`;
}
function redactPhone(phone) {
  if (!phone) return null;
  return phone.replace(/\d(?=\d{2})/g, '*');
}
return items.map(item => {
  const c = item.json;
  const norm = {
    claim_id: String(c.claim_id || c.id),
    customer_id: String(c.customer_id),
    customer_name: c.customer_name,
    contact_email: c.contact_email,
    contact_email_redacted: redactEmail(c.contact_email),
    contact_phone_redacted: redactPhone(c.contact_phone),
    claim_type: c.claim_type,
    amount: Number(c.amount),
    currency: c.currency || 'USD',
    incident_date: c.incident_date,
    submission_date: c.submission_date,
    description: c.description,
    location: c.location || null,
    policy_id: c.policy_id,
    prior_claims_count: Number(c.prior_claims_count || 0),
    policy_tenure_months: Number(c.policy_tenure_months || 0),
    risk_score: c.risk_score != null ? Number(c.risk_score) : null,
    attachments: c.attachments || [],
    // Raw source for audit
    _source: c,
  };
  return { json: norm };
});

A5) OpenAI: Chat (AI triage)
- Resource: Chat
- Model: gpt-4o-mini (or your approved model)
- Temperature: 0.2
- Response format: JSON if available in your OpenAI node; otherwise enforce via prompt.
- Messages:
  - System:
You are a cautious claims triage assistant. Output only valid JSON. Do not include explanations.
Fields: severity (1-5), fraud_risk (0-1), escalate_to_human (true/false), auto_approve (true/false), reasons (array of strings), recommended_next_steps (array of strings), customer_message_draft (string), customer_action (SEND_PAYOUT|REQUEST_INFO|DENY|MANUAL_CALL).
Strict JSON only.
  - User:
Business policy (summarized):
- Auto-approve if amount <= 1000 USD, tenure >= 12 months, prior_claims_count <= 1, no fraud signals.
- Escalate if fraud_risk >= 0.6, or severity >= 4, or amount > 5000 USD.
- If missing info, recommend REQUEST_INFO.
- Draft customer message in a polite, clear tone, <120 words.
Here is the claim JSON:
{{$json}}

Optional: If your OpenAI node supports “Response format: JSON”, set it and omit “Strict JSON only.”

A6) Function: Parse and validate LLM JSON
Purpose: Robustly parse the LLM output and enforce defaults.
Code:
/**
 * Parse LLM output safely and enforce schema defaults.
 */
function extractJson(text) {
  try {
    return JSON.parse(text);
  } catch (e) {
    const match = text.match(/\{[\s\S]*\}/);
    if (match) {
      try { return JSON.parse(match[0]); } catch {}
    }
    return null;
  }
}
function clamp(n, min, max) {
  return Math.max(min, Math.min(max, n));
}
return items.map(item => {
  const raw = item.json;
  const aiRaw = raw?.choices?.[0]?.message?.content || raw.content || raw.text || '';
  const parsed = extractJson(aiRaw) || {};
  const out = {
    severity: clamp(Number(parsed.severity || 3), 1, 5),
    fraud_risk: Math.max(0, Math.min(1, Number(parsed.fraud_risk || 0))),
    escalate_to_human: Boolean(parsed.escalate_to_human ?? false),
    auto_approve: Boolean(parsed.auto_approve ?? false),
    reasons: Array.isArray(parsed.reasons) ? parsed.reasons : [],
    recommended_next_steps: Array.isArray(parsed.recommended_next_steps) ? parsed.recommended_next_steps : [],
    customer_message_draft: String(parsed.customer_message_draft || ''),
    customer_action: parsed.customer_action || 'REQUEST_INFO',
    _llm_raw: raw,
  };
  return { json: out };
});

Note: In n8n, the OpenAI node returns a structured object; adjust the path in aiRaw according to your node output. If your OpenAI node outputs the final text directly at $json.data[0].content, update accordingly.

A7) Merge: Combine normalized claim + AI result
- Use a Merge node (Mode: Merge by position)
  - Input 1: from Normalize/Redact
  - Input 2: from Parse+Validate
- Resulting JSON will have both claim and ai fields in one item. If you prefer, combine inside a Function node instead:
Code:
/**
 * Combine previous node outputs into one object.
 * Use this node after connecting both inputs (Input 1 = claim, Input 2 = ai).
 */
return items.map((item, index) => {
  const claim = $items("Normalize and redact", 0, index).json;
  const ai = $items("Parse and validate LLM JSON", 0, index).json;
  return [{ json: { ...claim, ai } }];
}).flat();

A8) If: Decide auto vs. human
- Condition:
  - When: Expression
  - Value: {{ $json.ai.escalate_to_human || $json.ai.severity >= 4 || $json.amount > 5000 }}
  - True -> Needs Review
  - False -> Auto path

A9) Postgres: Upsert claim (Needs Review path)
- Credentials: Postgres (set up in n8n)
- Query (Execute Query):
CREATE TABLE IF NOT EXISTS claims (
  claim_id TEXT PRIMARY KEY,
  customer_id TEXT,
  customer_name TEXT,
  contact_email TEXT,
  contact_phone_redacted TEXT,
  claim_type TEXT,
  amount NUMERIC,
  currency TEXT,
  incident_date TIMESTAMP,
  submission_date TIMESTAMP,
  description TEXT,
  location TEXT,
  policy_id TEXT,
  prior_claims_count INT,
  policy_tenure_months INT,
  risk_score NUMERIC,
  status TEXT,
  severity INT,
  fraud_risk NUMERIC,
  escalate_to_human BOOLEAN,
  ai_reasons JSONB,
  ai_recommended_next_steps JSONB,
  ai_customer_message_draft TEXT,
  updated_at TIMESTAMP DEFAULT now(),
  source JSONB
);
INSERT INTO claims(
  claim_id, customer_id, customer_name, contact_email, contact_phone_redacted,
  claim_type, amount, currency, incident_date, submission_date, description,
  location, policy_id, prior_claims_count, policy_tenure_months, risk_score,
  status, severity, fraud_risk, escalate_to_human, ai_reasons,
  ai_recommended_next_steps, ai_customer_message_draft, updated_at, source
) VALUES (
  {{$json.claim_id}}, {{$json.customer_id}}, {{$json.customer_name}},
  {{$json.contact_email}}, {{$json.contact_phone_redacted}},
  {{$json.claim_type}}, {{$json.amount}}, {{$json.currency}},
  {{$json.incident_date}}, {{$json.submission_date}}, {{$json.description}},
  {{$json.location}}, {{$json.policy_id}}, {{$json.prior_claims_count}},
  {{$json.policy_tenure_months}}, {{$json.risk_score}},
  'NEEDS_REVIEW', {{$json.ai.severity}}, {{$json.ai.fraud_risk}},
  true, {{JSON.stringify($json.ai.reasons)}},
  {{JSON.stringify($json.ai.recommended_next_steps)}},
  {{$json.ai.customer_message_draft}}, now(), {{JSON.stringify($json._source)}}
)
ON CONFLICT (claim_id) DO UPDATE SET
  status='NEEDS_REVIEW',
  severity=EXCLUDED.severity,
  fraud_risk=EXCLUDED.fraud_risk,
  escalate_to_human=true,
  ai_reasons=EXCLUDED.ai_reasons,
  ai_recommended_next_steps=EXCLUDED.ai_recommended_next_steps,
  ai_customer_message_draft=EXCLUDED.ai_customer_message_draft,
  updated_at=now();

A10) Slack: Notify review queue (Needs Review path)
- Channel: #claims-review
- Message text:
New claim needs review
- Claim ID: {{$json.claim_id}}
- Amount: {{$json.amount}} {{$json.currency}}
- Severity: {{$json.ai.severity}} | Fraud risk: {{$json.ai.fraud_risk}}
- Reasons: {{ $json.ai.reasons.join('; ') }}
- Open in dashboard: https://your-dashboard.example.com/claims/{{$json.claim_id}}
Also include a link for reviewers that hits your Review Decision Receiver webhook (see below) with decision buttons if you implement interactive Slack via your app. Without interactivity, just link to your dashboard.

A11) Auto path: Update claims system
- HTTP Request:
  - Method: POST
  - URL: https://your-claims-api.example.com/claims/{{$json.claim_id}}/decisions
  - Body: JSON
{
  "decision": "AUTO_APPROVE",
  "severity": {{$json.ai.severity}},
  "fraud_risk": {{$json.ai.fraud_risk}},
  "reasons": {{JSON.stringify($json.ai.reasons)}}
}

A12) Auto path: Customer notification (Email or SMS)
- Gmail/SMTP node:
  - To: {{$json.contact_email}}
  - Subject: Update on your claim {{$json.claim_id}}
  - Body (HTML or text):
{{$json.ai.customer_message_draft}}

- Twilio node (optional SMS):
  - To: {{$json.contact_phone_redacted}}  // If you retain full phone, use that
  - Message: A short version of the draft

A13) Postgres: Log event (both paths)
- Query:
CREATE TABLE IF NOT EXISTS events (
  id SERIAL PRIMARY KEY,
  claim_id TEXT,
  event TEXT,
  payload JSONB,
  created_at TIMESTAMP DEFAULT now()
);
INSERT INTO events(claim_id, event, payload)
VALUES (
  {{$json.claim_id}},
  {{$json.ai.escalate_to_human ? 'NEEDS_REVIEW_QUEUED' : 'AUTO_DECIDED'}},
  {{JSON.stringify($json)}}
);

A14) Function: Advance watermark (polling only)
- Code:
const globalData = this.getWorkflowStaticData('global');
const maxDate = items.reduce((acc, item) => {
  const d = new Date(item.json.submission_date || 0).toISOString();
  return d > acc ? d : acc;
}, globalData.lastProcessedAt || '1970-01-01T00:00:00.000Z');
globalData.lastProcessedAt = maxDate;
return items;

Workflow B: Review Decision Receiver (Webhook-based human-in-the-loop)

B1) Webhook: /claims/review/decision
- Method: POST
- Expected JSON body:
{
  "claim_id": "C123",
  "reviewer": "jane.doe",
  "decision": "APPROVE" | "DENY" | "REQUEST_INFO" | "ESCALATE",
  "comment": "Optional notes for audit",
  "customer_message_override": "Optional custom text"
}

B2) Function: Validate payload
Code:
const { claim_id, reviewer, decision } = items[0].json || {};
if (!claim_id || !reviewer || !decision) {
  throw new Error('Missing required fields: claim_id, reviewer, decision');
}
return items;

B3) Postgres: Update claim + insert review
- Query:
CREATE TABLE IF NOT EXISTS reviews(
  id SERIAL PRIMARY KEY,
  claim_id TEXT,
  reviewer TEXT,
  decision TEXT,
  comment TEXT,
  created_at TIMESTAMP DEFAULT now()
);
UPDATE claims
SET status = 'DECIDED',
    updated_at = now()
WHERE claim_id = {{$json.claim_id}};
INSERT INTO reviews(claim_id, reviewer, decision, comment)
VALUES ({{$json.claim_id}}, {{$json.reviewer}}, {{$json.decision}}, {{$json.comment}});

B4) HTTP Request: Update claims system
- Method: POST
- URL: https://your-claims-api.example.com/claims/{{$json.claim_id}}/decisions
- Body: JSON
{
  "decision": {{$json.decision}},
  "reviewer": {{$json.reviewer}},
  "comment": {{$json.comment}}
}

B5) Customer notification
- Gmail/SMTP or Twilio:
  - Use message: {{$json.customer_message_override || "Your claim has been reviewed. "}} fallback to AI draft if stored in DB.
- If you need the AI draft from DB, add a Postgres "Select" before sending:
SELECT ai_customer_message_draft, contact_email
FROM claims
WHERE claim_id = {{$json.claim_id}}
LIMIT 1;

B6) Slack: Post review outcome
- Channel: #claims-review
- Message:
Decision recorded for {{$json.claim_id}}: {{$json.decision}} by {{$json.reviewer}}

B7) Postgres: Log event
INSERT INTO events(claim_id, event, payload)
VALUES (
  {{$json.claim_id}},
  'REVIEW_DECISION_APPLIED',
  {{JSON.stringify($json)}}
);

Workflow C: Error Handler

C1) Error Trigger
- Triggers when any workflow or node fails (configure your main workflows to use this error workflow).
- Data includes workflow name, node, error.

C2) Slack: Alert on-call
- Channel: #alerts
- Message:
n8n error in {{$json.workflow.name}} at node {{$json.node.name}}: {{$json.error.message}}
- Optionally include {{$json.executionId}} and a link to the execution.

C3) Postgres: Log error
INSERT INTO events(claim_id, event, payload)
VALUES (
  {{ $json?.execution?.data?.items?.[0]?.json?.claim_id || 'UNKNOWN' }},
  'ERROR',
  {{ JSON.stringify($json) }}
);

Step 5) Custom code guidance (helpers)

1) Fallback classification if LLM fails
Add an If node after Parse+Validate; if parsing failed or missing fields, run this Function:
const c = $json; // combined claim object if you merged
const auto = c.amount <= 1000 && c.policy_tenure_months >= 12 && c.prior_claims_count <= 1;
const severity = c.amount > 5000 ? 4 : (c.amount > 1000 ? 3 : 2);
return [
  {
    json: {
      ...c,
      ai: {
        severity,
        fraud_risk: c.risk_score != null ? Math.min(1, Math.max(0, c.risk_score / 100)) : 0.2,
        escalate_to_human: !auto || severity >= 4,
        auto_approve: auto && severity < 4,
        reasons: ['Fallback rules applied'],
        recommended_next_steps: [auto ? 'Proceed to payout' : 'Send to human review'],
        customer_message_draft: auto ? 'We are processing your claim. You will receive details shortly.' : 'We are reviewing your claim and will update you soon.',
        customer_action: auto ? 'SEND_PAYOUT' : 'REQUEST_INFO',
      },
    },
  },
];

2) Exponential backoff helper (for manual retries)
Use Wait + Function to compute a backoff before retrying an HTTP Request:
const attempt = Number($json.attempt || 1);
const waitMs = Math.min(30000, 1000 * Math.pow(2, attempt - 1)); // cap at 30s
return [{ json: { ...$json, attempt: attempt + 1, waitMs } }];

Then Wait node: Duration -> {{$json.waitMs}}

3) Idempotency guard (avoid double-processing same claim)
Place early Function:
const seen = this.getWorkflowStaticData('global');
const id = $json.claim_id || $json.id;
if (!id) return items; // or throw
if (seen[`claim_${id}`]) {
  // Drop item
  return [];
}
seen[`claim_${id}`] = true;
return items;

4) Basic PII masker (add/extend as needed)
- Already shown for email/phone; extend with address or SSN patterns if present.

Step 6) Retry logic, error handling, and fallbacks

- Node-level “Continue On Fail”: Leave off by default; when on, branch on $json.error to handle gracefully.
- Pattern: Manual retry
  - Try HTTP Request (Continue On Fail: On)
  - If $json.error exists:
    - Compute backoff (Function)
    - Wait (dynamic ms)
    - Try again (HTTP Request)
    - Repeat up to N attempts (track attempt in JSON and branch to fail if > N)
- LLM fallback
  - If Parse+Validate fails or severity missing:
    - Use fallback rules Function (above)
- Centralized error workflow
  - Configure your main workflows to use the Error Trigger workflow C.
  - Always log final failure and alert Slack.
- Partial failures
  - For customer comms failures, write an event and queue a “comms retry” workflow that scans events with failed status and retries with backoff.

Step 7) Store and reuse data

Recommended: Postgres
- Pros: ACID, easy joins for your dashboard, JSONB columns for AI fields.
- Tables: claims, reviews, events (DDL shown above).
- For your dashboard, point your BI/Retool/Metabase to this DB.

Lightweight: Google Sheets
- Create a sheet “claims” with columns:
  - claim_id, status, amount, currency, severity, fraud_risk, escalate_to_human, ai_reasons, ai_customer_message_draft, updated_at
- Use Google Sheets node:
  - Operation: Upsert (or Add/Update)
  - Key: claim_id

State across executions
- Watermark or small counters: use workflow static data (this.getWorkflowStaticData('global'))
- Small KV: n8n Data Store node (if you prefer, set key=’lastProcessedAt’, value=timestamp)

Step 8) External APIs and authentication

OpenAI
- In n8n: Credentials -> New -> OpenAI API
- Paste API key (store as environment variable in n8n if possible)
- In the OpenAI Chat node, select the credential. Set model, temperature, etc.

Slack
- Create a Slack app (if you need interactivity). For simple messages:
  - n8n Slack node supports OAuth2; connect your workspace.
- For interactive buttons:
  - Build a Slack app with Interactivity enabled and point to your Review Decision Receiver webhook URL.
  - Use Block Kit to send buttons with value payload containing claim_id and decision.
  - Slack will POST to your webhook on click.

Gmail/SMTP
- Gmail node (OAuth2) or SMTP with your provider.
- For SMTP: Credentials -> SMTP -> host, port, user, pass (use app passwords if Gmail).

Twilio (SMS)
- Twilio node -> Account SID + Auth Token.
- From number must be a Twilio-provisioned phone number.

Claims system API
- Use HTTP Request node with the right auth:
  - API key header: Authorization: Bearer {{$credentials.apiKey}}
  - Basic auth: set in node credentials
  - OAuth2: create OAuth2 credential; configure token URL, scopes.
- Test connectivity with a simple GET in n8n before wiring the full flow.

Security/Privacy
- Redact PII for LLM prompts when feasible.
- Don’t log full PII in events; keep sensitive fields in claims table with minimal exposure to logs.
- Use n8n credentials store; avoid hardcoding secrets in Function nodes.

Putting it together: minimal “happy path” build order
1) Create Postgres credentials and tables using the Postgres node.
2) Build Workflow A (Webhook Trigger -> Normalize -> OpenAI -> Parse -> If -> Auto path + Needs Review path + logging).
3) Build Workflow B (Webhook -> Validate -> Update DB -> Update claims system -> Notify customer -> Slack -> Log).
4) Create Workflow C (Error Trigger -> Slack -> Log).
5) Test with sample claim payloads; then connect real claims API/webhook.
6) Add retries and fallbacks once the happy path is green.

Testing tips
- Use the Webhook test URL in n8n to send sample claims JSON.
- Mock the claims API with httpbin or a mock server while building.
- Simulate LLM failures by forcing Parse+Validate to throw to verify fallbacks.

Expandability ideas
- Chain workflows: Break out “Customer Comms” into its own workflow and call via Execute Workflow for reuse and isolated retries.
- Add a vector database (e.g., pgvector in Postgres or Pinecone) to retrieve policy clauses and feed them into the LLM context for more accurate decisions.
- Connect to your CRM (Salesforce/HubSpot) to log customer interactions and set follow-up tasks.
- Slack interactivity: Add Approve/Deny buttons wired to your Review Decision Receiver webhook with Block Kit.
- Add a “Request More Info” path that generates a secure upload link and a form (Webhook + lightweight form page), then a Wait/Resume pattern to continue once customer responds.
- Observability: Push execution metrics and errors to Datadog/Grafana via HTTP or StatsD.
- Rate limiting: Introduce a queue (e.g., limit batch size with Split In Batches + Wait) for claims spikes.
- Attachments: Use Binary handling in n8n to fetch and virus-scan attachments before triage.

If you share your claims API shape and your preferred dashboard stack (Retool, internal Next.js, Google Sheets, etc.), I’ll tailor the exact node configs and payload contracts for you.
